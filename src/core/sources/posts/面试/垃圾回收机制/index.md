---

# 默认为文件名称
title: 

tags:
 - GC
 - v8

# 类别中已包含文件夹名称
categories:

description: javascript 的垃圾回收机制的过程与方法,v8引擎的运转过程

# 该字段必须,格式 <YYYY-MM-DD hh:mm:ss>
publishTime: 2022-09-04 23:35:24
updateTime:
 
# 默认随机
img: 

# 目录
toc: false

# 评论
comment: true

publish: true
---

# GC 机制

> 引自：
>
> - https://www.jb51.net/article/229425.htm
> - https://blog.csdn.net/weixin_43801836/article/details/126043564

## 为什么需要垃圾回收（GC）

- 在 JavaScript 中的字符串、对象、数组等数据的内存是不固定的，只有真正使用的时候才会动态分配内存。
- 这些数据所占的内存在不使用时，需要进行释放，以便再次使用，否则可用内存耗尽造成程序崩溃。



## 什么是垃圾回收

在 JavaScript 中拥有自动的垃圾回收机制，通过一些回收算法，找出不再使用引用的变量或属性，由 JS 引擎按照固定时间间隔周期性的释放其所占的内存空间



## 垃圾产生

当一个对象**没有任何的变量或属性对它进行引用**，此时我们将永远无法操作该对象，这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序变慢。

这个过程我们不需要也不能自己进行垃圾回收的操作，我们只需要的是**将不再使用的对象设置为 null** 即可



## 垃圾回收策略

JavaScript 中主要的内存管理概念是**可达性**。大概意思是**以某种方式可以访问到或者可以使用的值，它们就是需要保存在内存中，无法访问，也无法使用的值，则需要被垃圾回收机制回收**

垃圾回收过程是**不实时**进行的，因为 JavaScript 是一门单线程的语言，每次执行垃圾回收，会使程序应用**逻辑暂停**，执行完垃圾回收后在执行应用逻辑，这种行为称为**全停顿**，所以一般垃圾回收会在 CPU 空闲时进行



### 引用计数标记

**策略思想：**

- 跟踪记录每个变量值被使用的次数
- 当声明一个变量并且将一个引用类型数据赋值给这个变量的时候，这个引用类型数据的引用次数就标记为 1
- 如果当这个引用类型数据又赋值给另一个变量，那么引用次数就+1
- 如果变量被其他的值覆盖，则引用次数-1
- 当这个引用类型数据的引用次数变为0的时候,这个变量就没有被使用了，也无法访问，垃圾回收器就会在执行时，销毁引用次数为0的引用类型数据，回收其所占用的内存空间。



问题：**循环引用**

对象A的属性指向对象B,对象B的属性指向对象A,这个函数在执行完，对象A和B的计数器也不会为0，影响了正常的GC

```js
function test()
{
    let A = new Object();
    let B = new Object();
    A.pointer= B;
    B.pointer = A;
}
test();
```

当对象A和对象B的属性相互引用这，按照引用计数策略，他们的引用计数都是为 2,但是在 test() 执行完成后，在函数执行完，函数作用域中的数据对象 A 和对象 B 都应该被 GC 销毁掉。

如果执行多次，将会造成严重的内存泄漏。

解决方法：

在 A 与 B 使用完后手动将其置为 null

```js
//切断引用关系
A = null
B = null
```



优势：

- 最大限度减少 GC 时间，减少程序暂停时间

缺处：

- 无法回收循环引用的对象



### 标记清除算法

**大概过程：**

- 垃圾收集器在运行时会给内存中所有的变量都加上一个标记，假设内存中所有的对象全部是垃圾，全部标记为0
- 然后从各个**根对象**开始遍历，把不是垃圾的节点改成1
- 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
- 最后把所有内存中对象标记修改为0，等待下一轮的垃圾回收



优势：

- 实现简单，标记情况无非两种，通过二进制（0和1）就可以为其标记
- 能够回收循环引用的对象
- 是v8引擎使用最多的算法

缺处：

- 在清除垃圾之后，剩余对象的内存位置是不变的，就会导致空闲内存空间不连续。这样就出现了内存碎片，并且由于剩余空间不是整块，就需要内存分配的问题



### 标记整理算法

标记整理（Mark-Compact）算法，就是可以有效的解决，它是在标记结束后标记整理算法会将不需要清理的对象向内存一端移动，最后清理边界的内存



## v8引擎的垃圾回收

### v8内存大小

v8引擎中的内存使用： v8引擎在64位系统下最多只能使用约1.4GB的内存，在32位系统下最多只能使用约0.7GB的内存
v8的内存限制（为什么内存这么小，对内存进行限制呢？？）

- JS 是单线程，v8 执行垃圾回收时，程序中的其他各种逻辑都要进入暂停等待阶段，直到垃圾回收结束后才会再次重新执行 JS 逻辑。因此，由于 JS 的单线程机制，**垃圾回收的过程阻碍了主线程逻辑的执行**
- 垃圾回收本身也是一件非常耗时的操作，在垃圾回收的过程中浏览器一直处于等待的状态，同时会失去对用户的响应

因此如果内存使用过高，那么必然会导致垃圾回收的过程缓慢，也就**会导致主线程的等待时间越长，浏览器也就越长时间得不到响应**

### v8的垃圾回收策略

- V8引擎的垃圾回收采用**标记清除法与分代回收法**
- 分为新生代和老生代
  - 新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。
  - 老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象。



#### 新生代

新生代的垃圾回收过程中主要采用了Scavenge算法。新生代内存一分为二

处于激活状态的区域我们称为**From空间**，未激活(inactive new space)的区域我们称为**To空间**

这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。

程序中声明的对象首先会被分配到From空间，当进行垃圾回收时，如果From空间中尚有存活对象，则会被复制到To空间进行保存，非存活的对象会被自动回收。当复制完成后，From空间和To空间完成一次角色互换，To空间会变为新的From空间，原来的From空间则变为To空间



#### 晋升到老生代

当一个对象在新生代经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程我们称之为晋升。

对象晋升的条件主要有以下两个：

- 对象是否经历过一次Scavenge算法
- To空间的内存占比是否已经超过25%



#### 老生代

采用Mark-Sweep(标记清除)和Mark-Compact(标记整理)来进行管理

为了减少垃圾回收带来的停顿时间，V8引擎又引入了Incremental Marking(**增量标记**)的概念，即将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给JS主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。V8引擎后续继续引入了**延迟清理(lazy sweeping)和增量式整理**



## 如何防止内存泄露?

- 避免使用全局 var，（原因：使用 var 全局对象挂在到 window 上，在标记阶段因为 window 对象可以作为根节点，在 window 上挂载的属性均可以被访问到，并将其标记为活动的从而常驻内存，因此也就不会被垃圾回收，只有在整个进程退出时全局作用域才会被销毁）全局变量使用完毕后将其设置为 null 从而触发回收机制
- 少用闭包
- 手动关闭定时器
- 使用弱引用





















